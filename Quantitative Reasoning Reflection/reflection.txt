Andrew Samountry - 12/01/2021 - Quantitative Reflection


1. A lot of the technical problems that I had with my code, I began by
breaking it down into smaller problems. For instance, in the 3rd lab, we
were tasked with drawing a scene by using functions and 3+ lines of complexity
for the functions. I didn't know how to draw a basketball with the lines, so
I began by creating a circle, then using code that I knew how to use (lines and
curves) to create a basketball image.
    Another example of me using logical thinking to work through the problems
is deciding which method of code to use. When I first began learning about
If/Elif/Else and For/While loops, I was confused whenever I needed to implement
certain statements, when I could use either in a situation. But, in the Sprites
and Walls lab, it became tedious for myself to create walls and coins in the
same area, so I figured out how to create my own for loop to loop the walls
in a continuous line/spiral to create an obstacle for the player sprite.


2. Being very intentional with the way the code is written is important in communication thoughts
and ideas to other programmers who view your code. Things like comments or descriptive variables
make it easy for others to read and understand your progress. An example that I have using more structured
coding (instead of sloppy) is creating blocks of code, rather than a long line of code. Function names also matter
because it describes what the following set of code is set to do, rather than having someone guess on what
you're trying to do. Easier communication between programmers leads to a better understand overall for them to help
or learn from your own code.



3. A lot of the time when I'm trying to run code and it crashes, I try to view the error when it occurs. It usually
tells where the error would be in the program and what type of error it is. That is usually my first time in
trying to fix an error. I, then would try to see why the code failed when comparing my intended input and expected
output against what actually occurred. Using the debugger to run through each line to see where it would crash
is also another way of fixing the code.
An example of me actually trying to debug the code was during the text adventure lab. I kept getting the same output
when I would move into a new direction. THe same room description would occur. What I did to try and fix this was
create a new line to see if I actually moved into the new room when tested and when it didn't, I knew I had to fix
that line of code.


4. I think there are a lot of limitations to just using numerical methods to make decisions. As humans, we aren't black
and white. Unlike binary numbers which consists of just 0 and 1s, humans seem to make a lot of their own decisions based
off of feelings and instinct. A computer can't recognize the gray area between black and white because it only computes
what it takes in as an input and spits out an output. We can't evaluate students based solely on test scores because
many students have different strengths and weaknesses that make them unique. To categorize them into numbers isn't
fitting because everyone is different.


